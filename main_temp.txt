
    

    /*Eclaircissement: on utilise l'image convertie en noir et blanc. RGB->BW, que l'on libérera plus bas*/
    char brighten_op[9]="brighten";
    char *brighten_concat = concat_parts(dir,name,brighten_op,ext); 
    picture brightened = brighten_picture(conv2bw,1.5);

    write_picture(brightened,brighten_concat);
    clean_picture(&brightened);
    free(brighten_concat);

    clean_picture(&conv2bw);
    free(conv2bw_concat);

    /*Split & merge*/
    picture *split_test = split_picture(test);

    char split_shared_str[7] = "split_";
    for(char k=0;k<(char)test.chan_num;k++){
        printf("k:%d\n",(int)k);
        char *split_individualized_channel = malloc(sizeof(char)*8);

        size_t max_length = 8;
        strncpy(split_individualized_channel,split_shared_str,max_length);
        split_individualized_channel[6] = 48+k;
        split_individualized_channel[7] = '\0';
        char *split_channel_concat = concat_parts(dir,name,split_individualized_channel,pgm_ext);

        write_picture(split_test[(int)k],split_channel_concat);

        free(split_individualized_channel);
        free(split_channel_concat);
        
    }
    
    char merge_op[6] = "merge";
    char *merge_concat = concat_parts(dir,name,merge_op,ppm_ext);
    picture merged;
    if(test.chan_num == RGB_PIXEL_SIZE){
        merged = merge_picture(split_test[0],split_test[1],split_test[2]);
    }else{
        assert(test.chan_num == BW_PIXEL_SIZE);
        merged = merge_picture(split_test[0],split_test[0],split_test[0]);
    }
    

    write_picture(merged,merge_concat);
    clean_picture(&merged);
    free(merge_concat);
    for(char k=0;k<(char)test.chan_num;k++){
        clean_picture(&split_test[(int)k]);
    }
    free(split_test);

    
    picture melted = melt_picture(test,test.width*test.height*test.chan_num*5);
    char melted_op[7]="melted";
    char *melted_path = concat_parts(dir,name,melted_op,ext);

    write_picture(melted,melted_path);
    clean_picture(&melted);
    free(melted_path);


    /*LUT test*/
    /*1) Inversion*/
    picture inverted = inverse_picture(test);
    char inverted_op[9] = "inverted";
    char *inverted_path = concat_parts(dir,name,inverted_op,ext);

    write_picture(inverted,inverted_path);
    clean_picture(&inverted);
    free(inverted_path);

    /*2)Normalisation */
    picture normalized = normalize_dynamic_picture(test);
    char normalized_op[11] = "normalized";
    char *normalized_path = concat_parts(dir,name,normalized_op,ext);

    write_picture(normalized,normalized_path);
    clean_picture(&normalized);
    free(normalized_path);

    /* 'Discrétisation' en blocs plus grossiers*/
    picture discretized = set_levels_picture(test,8);
    char discretized_op[12] = "discretized";
    char *discretized_path = concat_parts(dir,name,discretized_op,ext);

    write_picture(discretized,discretized_path);
    clean_picture(&discretized);
    free(discretized_path);
    /* Distance (valeur absolue de la différence composante par composante)*/

    char path1[27] = "Lenna_input/Lenna_gray.pgm"; 
    char path2[25] = "Lenna_input/Lenna_BW.pgm";

    picture p1 = read_picture(path1);
    picture p2 = read_picture(path2);
    picture dist = distance_picture(p1,p2);
   
    char dist_op[9] = "distance";
    char *dist_path = concat_parts(dir,name,dist_op,pgm_ext);

    write_picture(dist,dist_path);
    clean_picture(&dist);
    free(dist_path);

    /*Produit composante par composante*/
    picture prod = mult_picture(p1,p2);
    char prod_op[5]="prod";
    char *prod_path = concat_parts(dir,name,prod_op,pgm_ext);

    write_picture(prod,prod_path);
    clean_picture(&prod);
    free(prod_path);

    clean_picture(&p1);
    clean_picture(&p2);

    /*
    char path_a[28]="Lenna_input/Lenna_color.ppm";//37] //= "Lenna_input/Lenna_color_inverted.ppm";
    char path_b[28]="Lenna_input/Lenna_color.ppm";
    char path_c[25] = "Lenna_input/Lenna_BW.pgm";

    char mix_op[4]="mix";
    char *mix_path = concat_parts(dir,name,mix_op,ppm_ext);

    picture p_a = read_picture(path_a);
    picture p_b = read_picture(path_b);
    picture p_c = read_picture(path_c);

    picture mixed = mix_picture(p_a,p_b,p_c);
    write_picture(mixed,mix_path);

    clean_picture(&mixed);
    free(mix_path);
    
    clean_picture(&p_a);
    clean_picture(&p_b);
    clean_picture(&p_c);
    */
    /*On libère les chemins*/