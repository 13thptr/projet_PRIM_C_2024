Reste à faire sur le projet C:

OBJECTIF / DATE LIMITE : TOUT FINIR AVANT LE JEUDI 2 JAN AU SOIR.

- OK Meta: Mettre le projet sur mon GitHub (dépôt privé, en tout cas pour le moment) et le pousser après chaque modification. OK


- OK 0: Faire en sorte que les fichiers images produits aillent dans Lenna_output au lieu de Lenna_input (jeu sur les chemins). + commit

    -> j'ai créé un fichier main_temp.txt pour travailler avec un main allégé et avoir l'esprit plus clair,
    sans perdre mon travail. Mentionner ce problème de précipitation dans le compte-rendu.


    -> Mentionner le fait que j'ai lu la consigne trop vite et que j'ai mal interprété le format d'entrée, ce qui m'a conduit à modifier le main
    par la suite.


    -> Choix à effectuer (en parler dans le compte rendu): 
    
        auparavant, j'avais le même nom, dir, ext pour tous les fichiers (puisque je n'avais en fait qu'une seule entrée).

        Je dois maintenant choisir de conserver ce système alors que j'ai plusieurs entrées, ce qui pose bien des problèmes (à détailler dans le rapport)
        ou plutôt garder séparément pour chaque fichier passé en argument son nom "nom", son répertoire "dir", et son extension "ext".

        Je choisis la 2ème option. Pour ce faire, j'utilise des tableaux de chaînes de caractères.

        -> Réalisation: des tableaux ?pour quoi faire ? Je n'ai pas besoin des précédents: je reviens sur de simples variables
        dir,name,ext que je vais mettre à jour à chaque tour de boucle.



- OK 1: Formater le main comme demandé. Factoriser au maximum pour la lisibilité. + commit


- OK 2: Terminer les fonctions voulues. + commit

- 2 bis: Faire le bonus. + commit

- 2 ter: ajouter une fonction de rotation d'image pour le fun. Test + commit

- 2 quater: Application d'une matrice de transformation globale. (généralisation de 2 ter).

- 3: Reprendre toutes les fonctions qui prennent une entrée utilisateur (en particulier read_picture)
    pour garantir la validité des images traitées. Tester sur les images incorrectes fournies + commit.
    Rendre read_picture plus robuste ou plus stricte ? Cf. espace P5 \n vs P5\n. La fonction doit-elle accepter la 1ère entrée ?


- 3 bis: (optionnel) Encapsuler les checks réalisés à l'étape 3 dans des fonctions pour les réutiliser 
    afin de vérifier la validité des images produites. + commit

- 3 ter: Créer ma propre image de test pour invalid_max puisque M. Burel a mis deux fois la même image "invalid_height.ppm"

- 3 quater: faire en sorte de prendre en compte la valeur maximale des pixels (cf. énoncé)

- 4: Ajouter les @assigns, @requires, @ensures et en profiter pour relire mon code, attentivement.+commit

- 5: Ajouter les "assert" qui vont bien, où il faut. +commit 

- 6: supprimer les fonctions et constantes inutilisées (je pense à la manipulation de pixels, à MAX_BYTE...) mentionner dans le rapport. + commit.

- 7: vérifier que tous les prototypes de fonctions correspondent bien à ce qui était demandé.

- 8: fusionner wrappers.h|c et safe_malloc.h|c ?

- 9: uniformiser mes conventions de code, les espaces, etc. "Prettifier" dans CLion ou avec une extension ? Un logiciel ?

- Remettre les options maximales de compilation, y compris ISO C / W old style / Werror

- Remplacer tous les "malloc" et "calloc" par "myalloc" (vérifier partout avec une recherche textuelle)

- Tester avec Valgrind. (désactiver fsanitize=address pour ce faire)

- Modifier le makefile pour utiliser une cible "all" tel que prescrit dans le cours.



- Ecrire un manuel d'utilisation du programme, affichable dans le terminal avec
     l'option --help et présent dans main.c sous forme de commentaire. Test + commit.


- Tester et re-tester, avec valgrind XOR ASan

- Ecrire le rapport en LaTeX. 
    -> Overleaf pour me simplifier la vie.

    + Mentionner le paramètre inutile, sa suppression et le traitement de la constante rendue inutile (?) MAX_BYTE.

    + Mentionner l'ajout dans filename.h et filename.c du mot clef "const" à cause de l'erreur -Wdiscarded-qualifiers.
    
    + Mentionner les histoires de if dans une double boucle (cf. pictures.c) et mon choix de factoriser (boucle d'abord, if ensuite)
      + le choix de l'optimisation à la compilation -O2 pour "compenser" ce genre de choses.
      

    + Mentionner l'autre modification apportée à filename.h - > Demander à momo ?

    + Parler de l'évolution des fonctions dans le temps: ajout de checks à la fin, difficultés éventuelles ou même absence de difficultés.
    
    + Faire une recherche du mot "rapport" dans tous les fichiers pour voir ce que j'aurais pu oublier
     
    + Section spécifique pour mix_picture qui m'a pris beaucoup de temps, notamment à cause du double free.

    + Mentionner l'incohérence potentielle entre le contenu d'un fichier (P5/P6) et son extension (ppm/pgm, dans l'ordre inverse fait exprès)
    et ce que j'ai fait pour y remédier. Notamment mix_picture: recombinaison des fichiers BW en fichiers PPM...

    + Section spécifique pour le bonus.

    + Section spécifique pour mes ajouts personnels: rotation puis plus généralement matrice de transformation (entrable en ligne de commande).

    + Dans une section spécifique "Outils et débogage", parler de la gestion avec git, des choix du Makefile,
    du débogage avec -fsanitize=address et Valgrind et éventuellement
    du bug de cette option avec le malloc fantôme (cf. historique avec git log pour comprendre de quoi je parle)

    + Mentionner le manuel d'utilisation avec --help, les limites du programme.

    + Mentionner les 2 phénomènes mémoire que je n'ai pas encore compris: le problème de malloc avec fsanitize (cf. git log)
        et l'absence de double free après resampling (cf. git log aussi)


    + Parler de la performance du programme (occupation mémoire mesurée avec ..., vitesse mesurée avec timespec ou similaire.)
    et de la façon dont il pourrait être amélioré, du plus simple au plus complexe:
     - gestion d'options en ligne de commande / gestion des chemins 
     - programmation multithread
     - GPU,
     - support de différents formats d'image: lecture, conversion de formats...




- Faire une première archive tar contenant tout ce travail sans aucune exception 

- Faire une seconde archive tar avec un .git modifié pour faire disparaître toute trace du fichier TODO.txt
    (permet de travailler git sur un exemple concret !)


- Faire une archive tar sans fichier git ni ce fichier TODO.

- 